/**
 * Cache of the contents of localisation files.
 */
package localisation

import (
	"github.com/MangoDowner/mediawiki/includes/php"
)

const VERSION = 4

/**
 * Class for caching the contents of localisation files, Messages*.php
 * and *.i18n.php.
 *
 * An instance of this class is available using Language::getLocalisationCache().
 *
 * The values retrieved from here are merged, containing items from extension
 * files, core messages files and the language fallback sequence (e.g. zh-cn ->
 * zh-hans -> en ). Some common errors are corrected, for example namespace
 * names with spaces instead of underscores, but heavyweight processing, such
 * as grammatical transformation, is done by the caller.
 */
type LocalisationCache struct {

	/** Configuration associative array */
	conf []string

	/**
	 * True if recaching should only be done on an explicit call to recache().
	 * Setting this reduces the overhead of cache freshness checking, which
	 * requires doing a stat() for every extension i18n file.
	 */
	manualRecache bool

	/**
	 * True to treat all files as expired until they are regenerated by this object.
	 */
	forceRecache bool

	/**
	 * The cache data. 3-d array, where the first key is the language code,
	 * the second key is the item key e.g. "messages", and the third key is
	 * an item specific subkey index. Some items are not arrays and so for those
	 * items, there are no subkeys.
	 */
	data map[string]map[string]map[string]string

	/**
	 * The persistent store object. An instance of LCStore.
	 *
	 * @var LCStore
	 */
	store interface{}

	/**
	 * A 2-d associative array, code/key, where presence indicates that the item
	 * is loaded. Value arbitrary.
	 *
	 * For split items, if set, this indicates that all of the subitems have been
	 * loaded.
	 */
	loadedItems map[string]map[string]string

	/**
	 * A 3-d associative array, code/key/subkey, where presence indicates that
	 * the subitem is loaded. Only used for the split items, i.e. messages.
	 */
	loadedSubitems map[string]map[string]string

	/**
	 * An array where presence of a key indicates that that language has been
	 * initialised. Initialisation includes checking for cache expiry and doing
	 * any necessary updates.
	 */
	initialisedLangs map[string]bool

	/**
	 * An array mapping non-existent pseudo-languages to fallback languages. This
	 * is filled by initShallowFallback() when data is requested from a language
	 * that lacks a Messages*.php file.
	 */
	shallowFallbacks map[string]interface{}

	/**
	 * An array where the keys are codes that have been recached by this instance.
	 */
	recachedLangs []string

	/**
	 * All item keys
	 */
	AllKeys []string

	/**
	 * Keys for items which consist of associative arrays, which may be merged
	 * by a fallback sequence.
	 */
	MergeableMapKeys []string

	/**
	 * Keys for items which are a numbered array.
	 */
	MergeableListKeys []string

	/**
	 * Keys for items which contain an array of arrays of equivalent aliases
	 * for each subitem. The aliases may be merged by a fallback sequence.
	 */
	MergeableAliasListKeys []string

	/**
	 * Keys for items which contain an associative array, and may be merged if
	 * the primary value contains the special array key "inherit". That array
	 * key is removed after the first merge.
	 */
	OptionalMergeKeys []string

	/**
	 * Keys for items that are formatted like $magicWords
	 */
	MagicWordKeys []string

	/**
	 * Keys for items where the subitems are stored in the backend separately.
	 */
	SplitKeys []string

	/**
	 * Keys which are loaded automatically by initLanguage()
	 */
	PreloadedKeys []string

	/**
	 * Associative array of cached plural rules. The key is the language code,
	 * the value is an array of plural rules for that language.
	 */
	PluralRules interface{}

	/**
	 * Associative array of cached plural rule types. The key is the language
	 * code, the value is an array of plural rule types for that language. For
	 * example, $pluralRuleTypes["ar"] = ["zero", "one", "two", "few", "many"].
	 * The index for each rule type matches the index for the rule in
	 * $pluralRules, thus allowing correlation between the two. The reason we
	 * don"t just use the type names as the keys in $pluralRules is because
	 * Language::convertPlural applies the rules based on numeric order (or
	 * explicit numeric parameter), not based on the name of the rule type. For
	 * example, {{plural:count|wordform1|wordform2|wordform3}}, rather than
	 * {{plural:count|one=wordform1|two=wordform2|many=wordform3}}.
	 */
	pluralRuleTypes interface{}

	mergeableKeys interface{}
}

func NewLocalisationCache() *LocalisationCache {
	this := new(LocalisationCache)
	this.AllKeys = []string{
		"fallback", "namespaceNames", "bookstoreList",
		"magicWords", "messages", "rtl", "capitalizeAllNouns", "digitTransformTable",
		"separatorTransformTable", "minimumGroupingDigits",
		"fallback8bitEncoding", "linkPrefixExtension",
		"linkTrail", "linkPrefixCharset", "namespaceAliases",
		"dateFormats", "datePreferences", "datePreferenceMigrationMap",
		"defaultDateFormat", "extraUserToggles", "specialPageAliases",
		"imageFiles", "preloadedMessages", "namespaceGenderAliases",
		"digitGroupingPattern", "pluralRules", "pluralRuleTypes", "compiledPluralRules",
	}
	this.MergeableMapKeys = []string{
		"messages", "namespaceNames",
		"namespaceAliases", "dateFormats", "imageFiles", "preloadedMessages",
	}
	this.MergeableListKeys = []string{"extraUserToggles"}
	this.OptionalMergeKeys = []string{"bookstoreList"}
	this.MagicWordKeys = []string{"magicWords"}
	this.SplitKeys = []string{"messages"}
	this.PreloadedKeys = []string{"dateFormats", "namespaceNames"}
	return this
}

/**
 * Get a cache item.
 *
 * Warning: this may be slow for split items (messages), since it will
 * need to fetch all of the subitems from the cache individually.
 * @param string $code
 * @param string $key
 * @return mixed
 */
func (l *LocalisationCache) GetItem(code, key string) interface{} {
	value, ok := l.loadedItems[code]
	if !ok  {
		l.loadItem(code, key)
	}
	_, ok = value[key]
	if !ok {
		l.loadItem(code, key)
	}
	_, ok = l.shallowFallbacks[code]
	if "fallback" == key && ok {
		return l.shallowFallbacks[code]
	}

	return l.data[code][key]
}

/**
 * Load an item into the cache.
 * @param string $code
 * @param string $key
 */
func (l *LocalisationCache) loadItem(code, key string) {
	if _, ok := l.initialisedLangs[code]; !ok {
		l.initLanguage(code)
	}

	// Check to see if initLanguage() loaded it for us
	if value, ok := l.loadedItems[code]; ok {
		if _, ok = value[key]; ok {
			return
		}
	}

	if value, ok := l.shallowFallbacks[code]; ok {
		l.loadItem(value.(string), key)
		return
	}

	if php.InArray(key, l.SplitKeys) {
		// TODO
		//subKeyList := l.getSubItem(code, "list", key)
	} else {

	}

	//TODO
}

/**
 * Get a subitem, for instance a single message for a given language.
 * @param string $code
 * @param string $key
 * @param string $subkey
 * @return mixed|null
 */
func (l *LocalisationCache) getSubitem(code, key, subkey string) interface{} {
	isSet1 := true
	value, ok := l.loadedSubitems[code]
	if ok {
		_, ok := value[key]
		if !ok {
			isSet1 = false
		}
	} else {
		isSet1 = false
	}
	isSet2 := true
	value1, ok := l.loadedItems[code]
	if ok {
		_, ok := value1[key]
		if !ok {
			isSet1 = false
		}
	} else {
		isSet1 = false
	}

	if !isSet1 && !isSet2 {
		l.loadSubItem(code, key, subkey)
	}

	return l.data[code][key][subkey]
	return nil
}

/**
 * Load a subitem into the cache
 * @param string $code
 * @param string $key
 * @param string $subkey
 */
func (l *LocalisationCache) loadSubItem(code, key, subKey string) {
	if !php.InArray(key, l.SplitKeys) {
		l.loadItem(code, key)
		return
	}

	if _, ok := l.initialisedLangs[code]; !ok {
		l.initLanguage(code)
	}

	// TODO
	return
}

/**
 * Initialise a language in this object. Rebuild the cache if necessary.
 * @param string $code
 * @throws MWException
 */
func (l *LocalisationCache) initLanguage(code string) (err error) {
	if _, ok := l.initialisedLangs[code]; ok {
		return
	}
	l.initialisedLangs[code] = true

	// If the code is of the wrong form for a Messages*.php file, do a shallow fallback
	//if languages.NewLanguage().IsValidBuiltInCode(code) {
	//	l.InitShallowFallback(code, "en")
	//	return
	//}

	// TODO
	return nil
}

/**
 * Create a fallback from one language to another, without creating a
 * complete persistent cache.
 * @param string $primaryCode
 * @param string $fallbackCode
 */
func (l *LocalisationCache) InitShallowFallback(primaryCode, fallbackCode string) {
	l.data[primaryCode] = l.data[fallbackCode]
	l.loadedItems[primaryCode] = l.loadedItems[fallbackCode]
	l.loadedSubitems[primaryCode] = l.loadedSubitems[fallbackCode]
	l.shallowFallbacks[primaryCode] = fallbackCode
}